<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HI!FEI!</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-06-09T07:33:29.219Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Feidashen</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="http://example.com/2024/06/09/MySQL/"/>
    <id>http://example.com/2024/06/09/MySQL/</id>
    <published>2024-06-09T07:32:59.000Z</published>
    <updated>2024-06-09T07:33:29.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="1-MySQL-执行流程是怎样的？"><a href="#1-MySQL-执行流程是怎样的？" class="headerlink" title="1.MySQL 执行流程是怎样的？"></a>1.MySQL 执行流程是怎样的？</h2><p>MySQL 的架构共分为两层：Server 层和存储引擎层：</p><ol><li><strong>Server 层</strong>负责建立连接、分析和执行 SQL（连接器，查询缓存、解析器、预处理器、优化器、执行器等，内置函数，跨存储引擎的功能）；</li><li><strong>存储引擎层</strong>负责数据的存储和提取（支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。）。</li></ol><p><strong>连接器</strong>：建立连接，管理连接、校验用户身份；</p><p><strong>查询缓存</strong>：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</p><p><strong>解析 SQL</strong>，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</p><p><strong>执行 SQL</strong>：执行 SQL 共有三个阶段：</p><ul><li>预处理阶段：检查表或字段是否存在；将 select * 中的 * 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul><h2 id="2-MySQL-的-NULL-值是怎么存放的？"><a href="#2-MySQL-的-NULL-值是怎么存放的？" class="headerlink" title="2.MySQL 的 NULL 值是怎么存放的？"></a>2.MySQL 的 NULL 值是怎么存放的？</h2><p>MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。</p><p>NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。</p><blockquote><p>表空间由段（segment）、区（extent）、页（page）、行（row）组成</p></blockquote><blockquote><ul><li>数据库表中的记录都是<strong>按行（row）进行存放的</strong>，每行记录根据不同的行格式，有不同的存储结构。</li><li>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。<br>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。<font color="#F100">默认每个页的大小为 16KB，也就是最多能保证 16KB 的连续存储空间。</font></li><li>InnoDB 存储引擎是用 B+ 树来组织数据的。在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了;</li><li><strong>表空间是由各个段（segment）组成的</strong>，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</li></ul></blockquote><blockquote><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合。</li></ul></blockquote><h2 id="3-MySQL-怎么知道-varchar-n-实际占用数据的大小？"><a href="#3-MySQL-怎么知道-varchar-n-实际占用数据的大小？" class="headerlink" title="3.MySQL 怎么知道 varchar(n) 实际占用数据的大小？"></a>3.MySQL 怎么知道 varchar(n) 实际占用数据的大小？</h2><p>MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。</p><h2 id="4-varchar-n-中-n-最大取值为多少？"><a href="#4-varchar-n-中-n-最大取值为多少？" class="headerlink" title="4.varchar(n) 中 n 最大取值为多少？"></a>4.varchar(n) 中 n 最大取值为多少？</h2><p>一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。</p><h2 id="5-行溢出后，MySQL-是怎么处理的？"><a href="#5-行溢出后，MySQL-是怎么处理的？" class="headerlink" title="5.行溢出后，MySQL 是怎么处理的？"></a>5.行溢出后，MySQL 是怎么处理的？</h2><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。</p><p>Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。</p><p>Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。</p><h2 id="6-为什么「变长字段长度列表」的信息要按照逆序存放？"><a href="#6-为什么「变长字段长度列表」的信息要按照逆序存放？" class="headerlink" title="6.为什么「变长字段长度列表」的信息要按照逆序存放？"></a>6.为什么「变长字段长度列表」的信息要按照逆序存放？</h2><p>因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中</strong>，这样就可以提高 CPU Cache 的命中率。</p><p>同样的道理， NULL 值列表的信息也需要逆序存放。</p><hr><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a>1.什么是索引？</h2><p>数据库中，索引的定义就是帮助存储引擎快速获取数据的一种数据结构，形象的说就是索引是数据的目录。</p><p>（1）按「数据结构」分类：B+Tree 索引、HASH 索引、Full-Text 索引。</p><p>（2）按「物理存储」分类：聚簇索引（主键索引）、二级索引（辅助索引）。</p><blockquote><p>主键索引的 B+Tree 的叶子节点存放的是<strong>实际数据</strong>，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</p></blockquote><blockquote><p>二级索引的 B+Tree 的叶子节点存放的是<strong>主键值</strong>，而不是实际数据。</p></blockquote><pre><code>聚簇索引字段选择：如果有主键，默认会使用主键作为聚簇索引的索引键（key）；如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</code></pre><p>（3）按「字段特性」分类：主键索引、唯一索引、普通索引、前缀索引。</p><ul><li><strong>主键索引</strong>就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</li><li><strong>唯一索引</strong>建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</li><li><strong>普通索引</strong>就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</li><li><strong>前缀索引</strong>是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</li></ul><p>（4）按「字段个数」分类：单列索引、联合索引。</p><ul><li>使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</li><li>(a, b, c) 联合索引，是先按 a 排序，在 a 相同的情况再按 b 排序，在 b 相同的情况再按 c 排序。所以，b 和 c 是全局无序，局部相对有序的，这样在没有遵循最左匹配原则的情况下，是无法利用到索引的。</li></ul><h2 id="2-什么时候需要-不需要创建索引？"><a href="#2-什么时候需要-不需要创建索引？" class="headerlink" title="2.什么时候需要 &#x2F; 不需要创建索引？"></a>2.什么时候需要 &#x2F; 不需要创建索引？</h2><p>索引最大的好处是提高查询速度，但是索引也是有缺点的，比如：</p><ul><li>需要占用物理空间，数量越大，占用空间越大；</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>会降低表的增删改的效率，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。</li></ul><p><strong>适用索引：</strong></p><ul><li>字段有唯一性限制的，比如商品编码；</li><li>经常用于 WHERE 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。</li><li>经常用于 GROUP BY 和 ORDER BY 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的。</li></ul><p><strong>不需要创建索引：</strong></p><ul><li>WHERE 条件，GROUP BY，ORDER BY 里用不到的字段，索引的价值是快速定位，如果<strong>起不到定位的字段</strong>通常是不需要创建索引的，因为索引是会占用物理空间的。</li><li><strong>字段中存在大量重复数据</strong>，不需要创建索引，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。在这些情况下，还不如不要索引，因为 MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</li><li><strong>表数据太少的时候</strong>，不需要创建索引；</li><li><strong>经常更新的字段</strong>不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，这个过程是会影响数据库性能的。</li></ul><h2 id="3-优化索引的方法？"><a href="#3-优化索引的方法？" class="headerlink" title="3.优化索引的方法？"></a>3.优化索引的方法？</h2><ol><li><p><strong>前缀索引优化</strong>：使用某个字段中字符串的前几个字符建立索引；</p><p> 使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。</p></li><li><p><strong>覆盖索引优化</strong>： SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作；</p><p> 使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作。</p></li><li><p>主键索引最好是自增的；</p><p> 如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为<strong>每次插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p> 如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><p> <font color="#F100">主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</font></p></li><li><p>索引最好设置为 NOT NULL：索引列要设置为 NOT NULL 约束；</p><ul><li><p>索引列存在 NULL 就<strong>会导致优化器在做索引选择的时候更加复杂</strong>，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为 NULL 的行。</p></li><li><p>NULL 值是一个没意义的值，但是它<strong>会占用物理空间</strong>，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式 (opens new window)中至少会用 1 字节空间存储 NULL 值列表，</p></li></ul></li><li><p>防止索引失效；</p><p> 发生索引失效的情况：</p><ul><li><pre><code>当我们使用**左或者左右模糊匹配**的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</code></pre></li><li><pre><code>当我们在查询条件中**对索引列做了计算、函数、类型转换操作**，这些情况下都会造成索引失效；</code></pre></li><li><pre><code>**联合索引要能正确使用需要遵循最左匹配原则**，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</code></pre></li><li><pre><code>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</code></pre></li></ul></li></ol><h2 id="4-InnoDB-是如何存储数据的？"><a href="#4-InnoDB-是如何存储数据的？" class="headerlink" title="4.InnoDB 是如何存储数据的？"></a>4.InnoDB 是如何存储数据的？</h2><p>InnoDB 的数据是按「数据页」为单位来读写的（数据库的 I&#x2F;O 操作的最小单位是页，InnoDB 数据页的默认大小是 16KB），每个数据页之间通过<strong>双向链表</strong>的形式组织起来，物理上不连续，但是逻辑上连续；</p><p>数据页内包含用户记录，每个记录之间用<strong>单向链表</strong>的方式组织起来，为了加快在数据页内高效查询记录，设计了一个<strong>页目录</strong>，页目录存储各个槽（分组），且主键值是有序的，于是可以通过二分查找法的方式进行检索从而提高效率。</p><blockquote><p><strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录，无需从最小记录开始遍历整个页中的记录链表。</p></blockquote><h2 id="5-B-树是如何进行查询的？"><a href="#5-B-树是如何进行查询的？" class="headerlink" title="5.B+ 树是如何进行查询的？"></a>5.B+ 树是如何进行查询的？</h2><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><p>如果叶子节点存储的是实际数据的就是聚簇索引，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是主键值则就是二级索引，一个表中可以有多个二级索引。</p><p>在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。</p><h2 id="6-为什么-MySQL-默认的存储引擎-InnoDB-采用的是-B-作为索引的数据结构？"><a href="#6-为什么-MySQL-默认的存储引擎-InnoDB-采用的是-B-作为索引的数据结构？" class="headerlink" title="6.为什么 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构？"></a>6.为什么 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构？</h2><p><font color="#F100">数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I&#x2F;O，而磁盘 I&#x2F;O 次数越多，所消耗的时间也就越大。</font></p><blockquote><p>磁盘读写的最小单位是扇区，扇区的大小只有 512B 大小，操作系统一次会读写多个扇区，所以操作系统的最小读写单位是<strong>块（Block）</strong>。Linux 中的块大小为 4KB，也就是一次磁盘 I&#x2F;O 操作会直接读写 8 个扇区。</p></blockquote><p>B 树，不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。<strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度。</strong></p><ul><li>B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I&#x2F;O 操作次数来读到「有用的索引数据」。</li><li>而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「<strong>非 A 记录节点」里的记录数据会从磁盘加载到内存</strong>，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I&#x2F;O 操作次数，也占用内存资源。</li></ul><p>B+ 树：</p><ol><li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li><li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li><li>非叶子节点中有多少个子节点，就有多少个索引；</li></ol><p><strong>B+ 和 B 树的性能区别：</strong></p><ul><li><strong>单点查询</strong>：B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少；</li><li><strong>插入和删除效率</strong>：B+ 树有大量的冗余节点，B + 树的插入和删除不需要变形，效率更高；</li><li><strong>范围查询</strong>： B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助；</li></ul><p>MySQL 中的 B+ 树特点：</p><ul><li>B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。</li><li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。</li></ul><p>总结：</p><ol><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</li><li>B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树。</li></ol><h2 id="7-为什么树的深度越深，IO次数越多？"><a href="#7-为什么树的深度越深，IO次数越多？" class="headerlink" title="7.为什么树的深度越深，IO次数越多？"></a>7.为什么树的深度越深，IO次数越多？</h2><p>树往往是用来存储数据的，树的一个节点往往对应着一个磁盘块，节点中可以存放数据，也可以存放指针（指针的指向就是节点对应的数据在磁盘中的位置），往往遍历获取树中数据的时候，我们就要与磁盘进行IO(读写操作)，而树的深度越深，那对应的节点不就越多，遍历时进行的IO操作也就越多。</p><h2 id="8-页的数据结构？"><a href="#8-页的数据结构？" class="headerlink" title="8.页的数据结构？"></a>8.页的数据结构？</h2><p><img src="/..%5Cimg%5C%E9%A1%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%841.jpg" alt="页的数据结构"><br><img src="/..%5Cimg%5C%E9%A1%B5%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842.jpg" alt="页的数据结构"></p><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p><p>数据页中的记录按照「主键」顺序组成单向链表，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个页目录，起到记录的索引作用。</p><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段；</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong>。</li></ol><h2 id="9-索引失效有哪些？"><a href="#9-索引失效有哪些？" class="headerlink" title="9.索引失效有哪些？"></a>9.索引失效有哪些？</h2><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 like %xx 或者 like %xx%这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列使用函数，就会导致索引失效（因为索引保存的是索引字段的原始值，而不是经过函数计算后的值）。</li><li>当我们在查询条件中对索引列进行表达式计算，也是无法走索引的（索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值）。</li><li>MySQL 在遇到字符串和数字比较的时候，会<strong>自动把字符串转为数字</strong>，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效（数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序）。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效（ OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的）。</li></ul><blockquote><p><strong>索引下推功能</strong>：可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。</p><p><strong>索引下推</strong>的大概原理是：截断的字段不会在 Server 层进行条件判断，而是会被下推到「存储引擎层」进行条件判断（因为 c 字段的值是在 (a, b, c) 联合索引里的），然后过滤出符合条件的数据后再返回给 Server 层。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。</p></blockquote><h2 id="10-MySQL-使用-like-“-x“，索引一定会失效吗？"><a href="#10-MySQL-使用-like-“-x“，索引一定会失效吗？" class="headerlink" title="10.MySQL 使用 like “%x“，索引一定会失效吗？"></a>10.MySQL 使用 like “%x“，索引一定会失效吗？</h2><p>不一定，使用左模糊匹配（like “%xx”）并不一定会走全表扫描，关键还是看数据表中的字段。</p><p>如果数据库表中的字段只有主键+二级索引，那么即使使用了左模糊匹配，也不会走全表扫描（type&#x3D;all），而是走全扫描二级索引树(type&#x3D;index)。</p><p>这张表的字段没有「非索引」字段，所以 select * 相当于 select id,name，然后这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。</p><h2 id="11-count-和-count-1-有什么区别？哪个性能最好？"><a href="#11-count-和-count-1-有什么区别？哪个性能最好？" class="headerlink" title="11.count(*) 和 count(1) 有什么区别？哪个性能最好？"></a>11.count(*) 和 count(1) 有什么区别？哪个性能最好？</h2><p><code>count() </code>是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是<strong>统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个</strong>。</p><ul><li>count（1）:常见计数方式，统计目标表的记录行数。括号里表示一个固定值，可以是任何固定的数字字符，是个常量。</li><li>count（*）:常见计数方式，统计目标表的记录行数，与count（1）执行结果相同，但是执行会根据目标表的不同进行优化。</li><li>count（列名）:常见计数方式，统计目标表某一列的非空记录数。它会统计指定列中不为NULL的行数，忽略NULL值。</li><li>count(distinct(列名)) ：其实是 count(列名) + distinct 的结果集，指定列不为NULL，并且在字段值重复的情况下只统计一次</li></ul><blockquote><p>count(1)其实是在统计表中有多少个记录。</p></blockquote><blockquote><p><code>count(*) </code>其实等于 count(0)，也就是说，当你使用 count(*) 时，MySQL 会将 * 参数转化为参数 0 来处理</p></blockquote><p><font color = "#F100">COUNT(*) &#x3D; COUNT(1) &gt; COUNT(字段)（存在二级索引）&gt; COUNT(主键字段)（仅存在主键索引）&gt;COUNT（非主键字段）（不存在二级索引）</font></p><blockquote><p>同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小，这样遍历二级索引的 I&#x2F;O 成本比遍历聚簇索引的 I&#x2F;O 成本小，因此「优化器」优先选择的是二级索引。</p></blockquote><p><code>count（*）</code>和<code>count（1）</code>执行机制存在差异，count（）函数在传入<code>*，1，2，&#39;abc&#39;</code>等值都会返回相同的结果；区别在于<code>count（*）</code>在传入<code>*</code>时，MySQL优化器会找到最小的那棵索引树进行遍历.</p><p>对于 count(1) 和 <code>count(*)</code> ，效率相当，建议尽量使用 <code>count(*)</code>，因为 MySQL 优化器会选择最小的索引树进行统计，针对此操作进行优化。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="1-事务有哪些特性？"><a href="#1-事务有哪些特性？" class="headerlink" title="1.事务有哪些特性？"></a>1.事务有哪些特性？</h2><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态;</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><blockquote><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p></blockquote><blockquote><ul><li>持久性是通过 redo log （重做日志）来保证的；</li></ul></blockquote><ul><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h2 id="2-并行事务会引发什么问题？"><a href="#2-并行事务会引发什么问题？" class="headerlink" title="2.并行事务会引发什么问题？"></a>2.并行事务会引发什么问题？</h2><ul><li><strong>脏读</strong>：一个事务「读到」了另一个「未提交事务修改过的数据」；</li><li><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况；</li><li><strong>幻读</strong>：在一个事务内多次查询某个符合查询条件的「记录数量」，前后两次查询到的记录数量不一样。</li></ul><p><font color="#F100">严重性排序：脏读 &gt; 不可重复读 &gt; 幻读</font></p><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低:</p><ol><li><strong>读未提交（read uncommitted）</strong>：指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（read committed）</strong>：指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（repeatable read）</strong>：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别；</li><li><strong>串行化（serializable ）</strong>：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ol><p><font color="#F100">按隔离水平高低排序如下：串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交</font></p><ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li><li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li><li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li><li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul><h2 id="3-隔离级别具体是如何实现的？"><a href="#3-隔离级别具体是如何实现的？" class="headerlink" title="3.隔离级别具体是如何实现的？"></a>3.隔离级别具体是如何实现的？</h2><ol><li>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以<strong>直接读取最新的数据</strong>就好了；</li><li>对于「串行化」隔离级别的事务来说，通过加<strong>读写锁</strong>的方式来避免并行访问；</li><li>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同，大家可以把 Read View 理解成一个数据快照，就像相机拍照那样，定格某一时刻的风景。「读提交」隔离级别是在「<strong>每个语句执行前</strong>」都会重新生成一个 Read View，而「可重复读」隔离级别是「<strong>启动事务时</strong>」生成一个 Read View，然后整个事务期间都在用这个 Read View。</li></ol><h2 id="4-Read-View-在-MVCC-里如何工作的？"><a href="#4-Read-View-在-MVCC-里如何工作的？" class="headerlink" title="4.Read View 在 MVCC 里如何工作的？"></a>4.Read View 在 MVCC 里如何工作的？</h2><p><img src="/..%5Cimg%5CReadView%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AE%B5.jpg" alt="页的数据结构"></p><p>Read View 有四个重要的字段：</p><ol><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的事务 id 列表，注意是一个列表，“活跃事务”指的就是，启动了但还没提交的事务。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 id 最小的事务，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是创建 Read View 时当前数据库中应该给下一个事务的 id 值，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是创建该 Read View 的事务的事务 id。</li></ol><p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后这个隐藏列是个指针，指向每一个旧版本记录，于是就可以通过它找到修改前的记录；</li></ul><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ol><li>如果记录的 trx_id 值小于 Read View 中的 min_trx_id 值，表示这个版本的记录是在<strong>创建 Read View 前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 max_trx_id 值，表示这个版本的记录是在<strong>创建 Read View 后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的 min_trx_id 和 max_trx_id 之间，需要判断 trx_id 是否在 m_ids 列表中：<ol><li>如果记录的 trx_id 在 m_ids 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务不可见。</li><li>如果记录的 trx_id 不在 m_ids列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务可见。</li></ol></li></ol><p>这种<strong>通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC</strong>（多版本并发控制）。</p><h2 id="5-MySQL-可重复读隔离级别，完全解决幻读了吗？"><a href="#5-MySQL-可重复读隔离级别，完全解决幻读了吗？" class="headerlink" title="5.MySQL 可重复读隔离级别，完全解决幻读了吗？"></a>5.MySQL 可重复读隔离级别，完全解决幻读了吗？</h2><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是通过 MVCC 方式解决了幻读，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是通过 next-key lock（记录锁+间隙锁）方式解决了幻读，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><blockquote><p>对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p></blockquote><blockquote><p>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p></blockquote><p><strong>MySQL 可重复读隔离级别并没有彻底解决幻读，只是很大程度上避免了幻读现象的发生。</strong></p><p><font color="#F100">要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select … for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</font></p><hr><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>##1.MySQL 有哪些锁？</p><p><strong>1.全局锁</strong></p><p>执行后，整个数据库就处于只读状态了，这时其他线程执行以下操作，都会被阻塞；</p><pre><code>flush tables with read lockunlock tables</code></pre><p>全局锁主要应用于做全库逻辑备份，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><p><strong>2.表级锁</strong></p><ul><li><strong>表锁</strong>：表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作（表锁的颗粒度太大，会影响并发性能）；</li><li><strong>元数据锁（MDL）</strong>：保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更（对数据库表进行操作时，会自动给这个表加上 MDL，事务执行期间，MDL 是一直持有的）;<ul><li>申请 MDL 锁的操作会形成一个队列，队列中写锁获取优先级高于读锁</li></ul></li><li><strong>意向锁</strong>：意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables … read）和独占表锁（lock tables … write）发生冲突（意向锁的目的是为了快速判断表里是否有记录被加锁）；<ul><li>   如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢 ；在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</li></ul></li><li><strong>AUTO-INC 锁</strong>：特殊的表锁机制，锁不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放；<ul><li>在插入数据时，会加一个表级别的 AUTO-INC 锁，然后为被 AUTO_INCREMENT 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉；</li></ul></li></ul><p><strong>3.行级锁</strong></p><p>nnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁</p><ul><li><strong>Record Lock</strong>，记录锁，也就是仅仅把一条记录锁上；</li><li><strong>Gap Lock</strong>，间隙锁，锁定一个范围，但是不包含记录本身（只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象）；</li><li><strong>Next-Key Lock</strong>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li><li><strong>插入意向锁</strong>：一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。<br>如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。(插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种<strong>特殊的间隙锁</strong>，属于行级别锁。)</li></ul><p><font color="#F100">MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁</font></p><p>如果说间隙锁锁住的是一个区间，那么<strong>「插入意向锁」锁住的就是一个点</strong>。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却<strong>不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁</strong>（当然，插入意向锁如果不在间隙锁区间内则是可以的）</p><h2 id="2-MySQL是怎么加锁的？"><a href="#2-MySQL是怎么加锁的？" class="headerlink" title="2.MySQL是怎么加锁的？"></a>2.MySQL是怎么加锁的？</h2><p>1.唯一索引等值查询：</p><ul><li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成「记录锁」。</li><li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成「间隙锁」</li></ul><p>2.非唯一索引等值查询：</p><ul><li>当查询的记录「存在」时，由于不是唯一索引，所以肯定存在索引值相同的记录，于是非唯一索引等值查询的过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描，然后在扫描的过程中，对扫描到的二级索引记录加的是 next-key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。同时，在符合查询条件的记录的主键索引上加记录锁。</li><li>当查询的记录「不存在」时，扫描到第一条不符合条件的二级索引记录，该二级索引的 next-key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。</li></ul><p><strong>非唯一索引和主键索引的范围查询的加锁规则不同之处在于：</strong></p><ul><li>唯一索引在满足一些条件的时候，索引的 next-key lock 退化为间隙锁或者记录锁。</li><li>非唯一索引范围查询，索引的 next-key lock 不会退化为间隙锁和记录锁。</li></ul><p>3.没有加索引的查询</p><p>执行 update、delete、select … for update 等具有加锁性质的语句，没有使用索引列作为查询条件，或者没有走索引，导致扫描是<strong>全表扫描</strong>。那么，每一条记录的索引上都会加 next-key 锁，这样就相当于锁住的全表，这时如果其他事务对该表进行增、删、改操作的时候，都会被阻塞。</p><h2 id="3-update-没加索引会锁全表？"><a href="#3-update-没加索引会锁全表？" class="headerlink" title="3.update 没加索引会锁全表？"></a>3.update 没加索引会锁全表？</h2><p>当我们要执行 update 语句的时候，确保 where 条件中带上了索引列，并且在测试机确认该语句是否走的是索引扫描，防止因为扫描全表，而对表中的所有记录加上锁。</p><p>我们可以打开 MySQL <code>sql_safe_updates</code> 参数，这样可以预防 update 操作时 where 条件没有带上索引列。</p><p>如果发现即使在 where 条件中带上了列索引列，优化器走的还是全标扫描，这时我们就要使用 force index([index_name]) 可以告诉优化器使用哪个索引。</p><h2 id="4-MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？"><a href="#4-MySQL-记录锁-间隙锁可以防止删除操作而导致的幻读吗？" class="headerlink" title="4.MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？"></a>4.MySQL 记录锁+间隙锁可以防止删除操作而导致的幻读吗？</h2><p>在 MySQL 的可重复读隔离级别下，针对当前读的语句会对索引加记录锁+间隙锁，这样可以避免其他事务执行增、删、改时导致幻读的问题。</p><p>有一点要注意的是，在执行 update、delete、select … for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了，这是挺严重的问题。</p><h2 id="5-MySQL-死锁了，怎么办？"><a href="#5-MySQL-死锁了，怎么办？" class="headerlink" title="5.MySQL 死锁了，怎么办？"></a>5.MySQL 死锁了，怎么办？</h2><p>行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。</p><p><strong>MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁。</strong></p><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ul><li><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li><li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li></ul><p>两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</p><blockquote><p>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</p></blockquote><p>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后<strong>插入意向锁和间隙锁之间是互斥的关系</strong>。</p><p><font color="#F00">如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：互斥、占有且等待、不可强占用、循环等待，因此发生了死锁。</font></p><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h2 id="1-执行一条-update-语句，期间发生了什么？"><a href="#1-执行一条-update-语句，期间发生了什么？" class="headerlink" title="1.执行一条 update 语句，期间发生了什么？"></a>1.执行一条 update 语句，期间发生了什么？</h2><pre><code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code></pre><ol><li>客户端先通过连接器建立连接，连接器自会判断用户身份；</li><li>因为这是一条 update 语句，所以不需要经过查询缓存，但是表上有更新语句，是会把整个表的查询缓存清空的，所以说查询缓存很鸡肋，在 MySQL 8.0 就被移除这个功能了；</li><li>解析器会通过词法分析识别出关键字 update，表名等等，构建出语法树，接着还会做语法分析，判断输入的语句是否符合 MySQL 语法；</li><li>预处理器会判断表和字段是否存在；</li><li>优化器确定执行计划，因为 where 条件中的 id 是主键索引，所以决定要使用 id 这个索引；</li><li>执行器负责具体执行，找到这一行，然后更新。</li></ol><blockquote><p>更新语句的流程会涉及到 undo log（回滚日志）、redo log（重做日志） 、binlog （归档日志）这三种日志：</p><ul><li>undo log（回滚日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的原子性，主要用于事务回滚和 MVCC。</li><li>redo log（重做日志）：是 Innodb 存储引擎层生成的日志，实现了事务中的持久性，主要用于掉电等故障恢复；</li><li>binlog （归档日志）：是 Server 层生成的日志，主要用于数据备份和主从复制；</li></ul></blockquote><h2 id="2-为什么需要-undo-log？"><a href="#2-为什么需要-undo-log？" class="headerlink" title="2.为什么需要 undo log？"></a>2.为什么需要 undo log？</h2><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><blockquote><p>Undo 页是记录什么？</p></blockquote><blockquote><p>开启事务后，InnoDB 层更新记录前，首先要记录相应的 undo log，如果是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面。</p></blockquote><h2 id="3-为什么需要-Buffer-Pool？"><a href="#3-为什么需要-Buffer-Pool？" class="headerlink" title="3.为什么需要 Buffer Pool？"></a>3.为什么需要 Buffer Pool？</h2><p>Innodb 存储引擎设计了一个缓冲池（Buffer Pool），来<strong>提高数据库的读写性能</strong>。</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取；</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘；</li></ul><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间</strong>，然后按照默认的 <code>16KB</code> 的大小划分出一个个的页， Buffer Pool 中的页就叫做<strong>缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><p>当我们查询一条记录时，InnoDB 是会把<strong>整个页</strong>的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「<strong>页目录</strong>」去定位到某条具体的记录。</p><h2 id="4-为什么需要-redo-log-？"><a href="#4-为什么需要-redo-log-？" class="headerlink" title="4.为什么需要 redo log ？"></a>4.为什么需要 redo log ？</h2><p>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先<strong>更新内存</strong>（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。</p><p>后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 WAL （Write-Ahead Logging）技术。</p><blockquote><p><font color="#F100">WAL 技术指的是， <strong>MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。 </font></p></blockquote><p>redo log 是<strong>物理日志</strong>，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p>1.<strong>实现事务的持久性，让 MySQL 有 crash-safe 的能力</strong>，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失:</p><ul><li>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。</li><li>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</li></ul><p>2.<strong>将写操作从「随机写」变成了「顺序写」</strong>，提升 MySQL 写入磁盘的性能：</p><ul><li>写入 redo log 的方式使用了追加操作， 所以磁盘操作是顺序写，而写入数据需要先找到写入位置，然后才写到磁盘，所以磁盘操作是随机写。磁盘的「顺序写 」比「随机写」 高效的多，因此 redo log 写入磁盘的开销更小。</li></ul><blockquote><p>实际上， 执行一个事务的过程中，产生的 redo log 也不是直接写入磁盘的，因为这样会产生大量的 I&#x2F;O 操作，而且磁盘的运行速度远慢于内存。</p><p>所以，redo log 也有自己的缓存—— redo log buffer（默认大小 16 MB），每当产生一条 redo log 时，会先写入到 redo log buffer，后续在持久化到磁盘</p></blockquote><h2 id="5-redo-log-和-undo-log-区别在哪？"><a href="#5-redo-log-和-undo-log-区别在哪？" class="headerlink" title="5.redo log 和 undo log 区别在哪？"></a>5.redo log 和 undo log 区别在哪？</h2><p>这两种日志是属于 InnoDB 存储引擎的日志，它们的区别在于：</p><ul><li>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；</li><li>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</li></ul><p>事务提交之前发生了崩溃，重启后会通过 undo log 回滚事务，事务提交之后发生了崩溃，重启后会通过 redo log 恢复事务.</p><h2 id="6-redo-log-什么时候刷盘？"><a href="#6-redo-log-什么时候刷盘？" class="headerlink" title="6.redo log 什么时候刷盘？"></a>6.redo log 什么时候刷盘？</h2><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘。</li></ul><p>数据安全性和写入性能是熊掌不可得兼的，要不追求数据安全性，牺牲性能；要不追求性能，牺牲数据安全性。</p><h2 id="7-redo-log-文件写满了怎么办？"><a href="#7-redo-log-文件写满了怎么办？" class="headerlink" title="7.redo log 文件写满了怎么办？"></a>7.redo log 文件写满了怎么办？</h2><p>默认情况下， InnoDB 存储引擎有 1 个重做日志文件组( redo log Group），「重做日志文件组」由有 2 个 redo log 文件组成，这两个 redo 日志的文件名叫 ：<code>ib_logfile0</code> 和 <code>ib_logfile1</code>。</p><p>在重做日志组中，每个 redo log File 的大小是固定且一致的；</p><p>重做日志文件组是以循环写的方式工作的，从头开始写，写到末尾就又回到开头，相当于一个环形。</p><p>InnoDB 存储引擎会先写 <code>ib_logfile0</code> 文件，当 <code>ib_logfile0</code> 文件被写满的时候，会切换至 <code>ib_logfile1</code> 文件，当 <code>ib_logfile1</code> 文件也被写满时，会切换回 <code>ib_logfile0</code> 文件。</p><p>redo log 是循环写的方式，相当于一个环形，InnoDB 用 write pos 表示 redo log 当前记录写到的位置，用 check point 表示当前要擦除的位置，</p><p>如果 write pos 追上了 check point，就意味着 <strong>redo log 文件满了，这时 MySQL 不能再执行新的更新操作，也就是说 MySQL 会被阻塞</strong>（因此所以针对并发量大的系统，适当设置 redo log 的文件大小非常重要），此时会停<strong>下来将 Buffer Pool 中的脏页刷新到磁盘中，然后标记 redo log 哪些记录可以被擦除，接着对旧的 redo log 记录进行擦除，等擦除完旧记录腾出了空间，checkpoint 就会往后移动（图中顺时针）</strong>，然后 MySQL 恢复正常运行，继续执行新的更新操作。</p><h2 id="8-为什么需要-binlog-？"><a href="#8-为什么需要-binlog-？" class="headerlink" title="8.为什么需要 binlog ？"></a>8.为什么需要 binlog ？</h2><p>undo log 和 redo log 这两个日志都是 Innodb 存储引擎生成的。</p><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事物执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p><p>binlog 文件是记录了<strong>所有数据库表结构变更和表数据修改的日志</strong>，不会记录查询类的操作，比如 SELECT 和 SHOW 操作。</p><p><strong>redo log 和 binlog 有什么区别？</strong></p><ol><li><p><strong>适用对象不同：</strong></p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul></li><li><p><strong>文件格式不同：</strong></p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）【每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志）），主从复制中 slave 端再根据 SQL 语句重现】、ROW【记录行数据最终被修改成什么样了】、 MIXED【包含了 STATEMENT 和 ROW 模式】</li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新；</li></ul></li><li><p><strong>写入方式不同：</strong></p><ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul></li><li><p><strong>用途不同：</strong></p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul></li></ol><h2 id="9-主从复制是怎么实现？"><a href="#9-主从复制是怎么实现？" class="headerlink" title="9.主从复制是怎么实现？"></a>9.主从复制是怎么实现？</h2><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。</p><p>这个过程一般是异步的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>具体过程：</p><ol><li>MySQL 主库在收到客户端提交事务的请求之后，会先写入 binlog，再提交事务，更新存储引擎中的数据，事务提交完成后，返回给客户端“操作成功”的响应。</li><li>从库会创建一个专门的 I&#x2F;O 线程，连接主库的 log dump 线程，来接收主库的 binlog 日志，再把 binlog 信息写入 relay log 的中继日志里，再返回给主库“复制成功”的响应。</li><li>从库会创建一个用于回放 binlog 的线程，去读 relay log 中继日志，然后回放 binlog 更新存储引擎中的数据，最终实现主从的数据一致性。</li></ol><h2 id="10-事务提交为什么需要两阶段提交？"><a href="#10-事务提交为什么需要两阶段提交？" class="headerlink" title="10.事务提交为什么需要两阶段提交？"></a>10.事务提交为什么需要两阶段提交？</h2><p>避免出现两份日志之间的逻辑不一致的问题</p><p>在持久化 redo log 和 binlog 这两份日志的时候，如果出现<strong>半成功</strong>的状态，就会造成主从环境的数据不一致性。这是因为 redo log 影响主库的数据，binlog 影响从库的数据，所以 redo log 和 binlog 必须保持一致才能保证主从数据一致。</p><p>两阶段提交其实是<strong>分布式事务一致性协议</strong>，它可以保证多个逻辑操作要不全部成功，要不全部失败，不会出现半成功的状态。</p><p>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。</p><blockquote><p>在 MySQL 的 InnoDB 存储引擎中，开启 binlog 的情况下，MySQL 会同时维护 binlog 日志与 InnoDB 的 redo log，为了保证这两个日志的一致性，MySQL 使用了<strong>内部 XA 事务</strong>，<strong>内部 XA 事务由 binlog 作为协调者，存储引擎是参与者</strong>。</p></blockquote><p>事务的提交过程有两个阶段，就是将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入binlog，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit &#x3D; 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog，然后将 binlog 持久化到磁盘（sync_binlog &#x3D; 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><p><font color="#F100">两阶段提交是以 binlog 写成功为事务提交成功的标识，因为 binlog 写成功了，就意味着能在 binlog 中查找到与 redo log 相同的 XID</font></p><h2 id="11-两阶段提交有什么问题？"><a href="#11-两阶段提交有什么问题？" class="headerlink" title="11.两阶段提交有什么问题？"></a>11.两阶段提交有什么问题？</h2><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I&#x2F;O 次数高</strong>：对于“双1”配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><p><strong>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I&#x2F;O 的次数</strong></p><p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li>flush 阶段：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）【用于支撑 redo log 的组提交】；</li><li>sync 阶段：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）【组合更多事务的 binlog，然后再一起刷盘】；</li><li>commit 阶段：各个事务按顺序做 InnoDB commit 操作；</li></ul><p>上面的每个阶段都有一个队列，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整</p><h2 id="12-具体更新一条记录-UPDATE-t-user-SET-name-xiaolin-WHERE-id-1-的流程"><a href="#12-具体更新一条记录-UPDATE-t-user-SET-name-xiaolin-WHERE-id-1-的流程" class="headerlink" title="12.具体更新一条记录 UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1; 的流程"></a>12.具体更新一条记录 <code>UPDATE t_user SET name = &#39;xiaolin&#39; WHERE id = 1;</code> 的流程</h2><ol><li>执行器负责具体执行，会调用存储引擎的接口，通过主键索引树搜索获取 id &#x3D; 1 这一行记录：<ol><li>如果 id&#x3D;1 这一行所在的数据页本来就在 buffer pool 中，就直接返回给执行器更新；</li><li>如果记录不在 buffer pool，将数据页从磁盘读入到 buffer pool，返回记录给执行器。</li></ol></li><li>执行器得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样：<ol><li>如果一样的话就不进行后续更新流程；</li><li>如果不一样的话就把更新前的记录和更新后的记录都当作参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作；</li></ol></li><li>开启事务， InnoDB 层更新记录前，首先要记录相应的 undo log，因为这是更新操作，需要把被更新的列的旧值记下来，也就是要生成一条 undo log，undo log 会写入 Buffer Pool 中的 Undo 页面，不过在内存修改该 Undo 页面后，需要记录对应的 redo log。</li><li>InnoDB 层开始更新记录，会先更新内存（同时标记为脏页），然后将记录写到 redo log 里面，这个时候更新就算完成了。为了减少磁盘I&#x2F;O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。这就是 WAL 技术，MySQL 的写操作并不是立刻写到磁盘上，而是先写 redo 日志，然后在合适的时间再将修改的行数据写到磁盘上。</li><li>至此，一条记录更新完了。</li><li>在一条更新语句执行完成后，然后开始记录该语句对应的 binlog，此时记录的 binlog 会被保存到 binlog cache，并没有刷新到硬盘上的 binlog 文件，在事务提交时才会统一将该事务运行过程中的所有 binlog 刷新到硬盘。</li><li>事务提交（为了方便说明，这里不说组提交的过程，只说两阶段提交）：<ol><li>prepare 阶段：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li>commit 阶段：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li></ol></li><li>至此，一条更新语句执行完成。</li></ol><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="1-为什么要有-Buffer-Pool？"><a href="#1-为什么要有-Buffer-Pool？" class="headerlink" title="1.为什么要有 Buffer Pool？"></a>1.为什么要有 Buffer Pool？</h2><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。</li></ul><blockquote><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连<strong>续的内存空间</strong>，默认配置下 Buffer Pool 只有 128MB 。</p><p>可以通过调整 innodb_buffer_pool_size 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%</p></blockquote><p>InnoDB 会把存储的数据划分为若干个「页」，以页作为磁盘和内存交互的基本单位，<strong>一个页的默认大小为 16KB</strong>。因此，<strong>Buffer Pool 同样需要按「页」来划分</strong>。Buffer Pool 中的页就叫做缓存页。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。</p><ul><li>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</li><li>InnoDB 为每一个缓存页都创建了一个控制块，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页。</li></ul><p><strong>查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，因为，通过索引只能定位到磁盘中的页，而不能定位到页中的一条记录。</strong>将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。</p><h2 id="2-如何管理-Buffer-Pool？"><a href="#2-如何管理-Buffer-Pool？" class="headerlink" title="2.如何管理 Buffer Pool？"></a>2.如何管理 Buffer Pool？</h2><p><strong>1.空闲页</strong></p><p>使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为** Free 链表**（空闲链表）。</p><ul><li>Free 链表上除了有控制块，还有一个头节点，该头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息。</li><li>每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。</li></ul><p><strong>2.脏页</strong></p><p><strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p><p>有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。</p><p><strong>3.提高缓存命中率</strong></p><p>将 LRU 划分了 2 个区域：old 区域 和 young 区域，young 区域在 LRU 链表的前半部分，old 区域则是在后半部分；</p><ul><li>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。（<strong>预读失效</strong>）</li><li>进入到 young 区域条件增加了一个停留在 old 区域的时间判断（<strong>Buffer Pool 污染</strong>）：<ul><li>如果后续的访问时间与第一次访问的时间在某个时间间隔内，那么该缓存页就不会被从 old 区域移动到 young 区域的头部；</li><li>如果后续的访问时间与第一次访问的时间不在某个时间间隔内，那么该缓存页移动到 young 区域的头部；</li></ul></li></ul><p><font color="#F100">每次访问都把预读的数据作为热点数据，排挤了原有的热点，导致预读失效，因此提高成为热点的门槛（二次访问才变热点）。可是全表扫描的的二次访问导致不需要的数据又挤走了热点，导致buff污染，因此继续提高变热门槛（二次访问间隔够长才能变热）</font></p><h2 id="3-会触发脏页刷新的几种情况"><a href="#3-会触发脏页刷新的几种情况" class="headerlink" title="3.会触发脏页刷新的几种情况"></a>3.会触发脏页刷新的几种情况</h2><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h1&gt;&lt;h2 id=&quot;1-MySQL-执行流程是怎样的？&quot;&gt;&lt;a href=&quot;#1-MySQL-执行流程是怎样的？&quot; class=&quot;headerlink</summary>
      
    
    
    
    
    <category term="Offer" scheme="http://example.com/tags/Offer/"/>
    
  </entry>
  
  <entry>
    <title>敏捷开发</title>
    <link href="http://example.com/2024/04/27/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/"/>
    <id>http://example.com/2024/04/27/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91/</id>
    <published>2024-04-27T12:18:22.000Z</published>
    <updated>2024-04-27T12:49:28.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="敏捷或敏捷方法或敏捷过程定义"><a href="#敏捷或敏捷方法或敏捷过程定义" class="headerlink" title="敏捷或敏捷方法或敏捷过程定义"></a>敏捷或敏捷方法或敏捷过程定义</h1><p>顾名思义，敏捷方法论是一组方法和实践，其中软件开发和项目管理发生在称为冲刺的短开发周期中交付以客户为中心的产品。这是一种迭代方法，每次迭代都经过专门设计，体积小且易于管理，以便可以在特定的给定时间段内交付。敏捷方法对随时间变化的需求持开放态度，并鼓励最终用户不断反馈。这是最受欢迎的方法，因为在此过程中，客户也参与其中，以便他们可以获得有关其产品的更新，并确保他们是否满足其要求。</p><h1 id="基本敏捷面试问题"><a href="#基本敏捷面试问题" class="headerlink" title="基本敏捷面试问题"></a>基本敏捷面试问题</h1><h2 id="1-敏捷方法有哪些不同类型？"><a href="#1-敏捷方法有哪些不同类型？" class="headerlink" title="1. 敏捷方法有哪些不同类型？"></a>1. 敏捷方法有哪些不同类型？</h2><p><strong>Scrum（敏捷）</strong>：它用于建立假设，测试它们，反思经验，并进行调整。它在很大程度上取决于反馈、自我管理、小团队和分解为冲刺的工作。它依赖于增量开发。</p><p><strong>FDD（功能驱动开发）</strong>：它通常涉及每两周创建一次软件模型，并且还需要为每个模型功能进行开发和设计。它基本上是一个轻量级的迭代和增量软件开发过程，其主要目的是按时交付稳定且有效的软件。</p><p><strong>Lean Software Development（精益软件开发）</strong>：它基本上是一种最大限度地减少浪费和最大化价值的方法。它更注重流程效率，以实现客户价值的最佳结果。它完全基于两个指导原则，即尊重人和持续改进。</p><p><strong>XP（极限编程）</strong>：其主要目的是为开发团队生产更高质量的软件和更高质量的生活。它被认为是低风险，灵活的，是一种开发软件并确保客户获得所需内容的方法。在这种方法中，软件从第一天起就进行测试，收集反馈以改进开发过程。</p><p><strong>DSDM（动态软件开发方法）</strong>：它通常侧重于整个项目生命周期，主要目的是确保良好的治理作为项目管理的基础。它是用户驱动的，并相信对项目的修改总是在意料之中的。它还提供了在预算范围内按时交付产品的完整路线图。</p><p><strong>ASD（自适应系统开发）</strong>：它代表了项目应该始终处于持续适应状态的想法，并且具有三个重复序列的循环，即推测，协作和学习。</p><p><strong>Crystal Methodology（晶体方法）</strong>：它主要关注个人及其互动，而不是过程。它被认为是开发软件的最轻量级和最灵活的方法之一。它是一系列敏捷方法，包括不同的变体，如晶莹剔透、晶黄、晶橙和晶红。</p><p><strong>Kanban（看板）</strong>：看板项目通常通过看板或表（看板）进行管理。这个看板是一个工具，可以帮助团队成员密切关注工作流程以衡量其进度，并包括每个阶段需要对产品完成的所有信息及其完成路径。其主要目的是任务管理的灵活性、持续改进和增强的工作流程。</p><h2 id="2-敏捷过程的优缺点是什么？"><a href="#2-敏捷过程的优缺点是什么？" class="headerlink" title="2.敏捷过程的优缺点是什么？"></a>2.敏捷过程的优缺点是什么？</h2><p>使用敏捷过程有几个优点：</p><ul><li>很好地适应不断变化的需求</li><li>与团队成员和客户面对面对话</li><li>专注于卓越的技术和良好的设计</li><li>快速和持续的开发</li><li>实现客户和项目团队之间的协作和互动</li><li>确保和促进客户满意度</li><li>更快地从客户或最终用户获得反馈</li><li>快速识别并消除代码中发现的错误</li><li>将敏捷项目划分为冲刺或迭代，即通常长达 1-4 周的短且可重复的阶段</li><li>快速交付产品</li><li>易于管理，更灵活</li><li>最终目标可能是未知的：敏捷对于未定义目标的项目是有益的，随着项目的进展，目标变得更加明显。</li></ul><p>使用敏捷过程有几个缺点：</p><ul><li>缺乏正式的文档和设计</li><li>难以估计资源需求和工作量</li><li>不适合小型开发项目</li><li>与其他开发方法相比成本高昂</li><li>需要每个人投入更多的时间和精力</li><li>项目永恒的风险</li><li>难以扩展大型项目</li><li>测试和测试施工困难。</li></ul><h2 id="3-解释敏捷测试？敏捷测试的原则是什么？"><a href="#3-解释敏捷测试？敏捷测试的原则是什么？" class="headerlink" title="3.解释敏捷测试？敏捷测试的原则是什么？"></a>3.解释敏捷测试？敏捷测试的原则是什么？</h2><p>顾名思义，敏捷测试是一个软件测试过程，其中软件针对任何缺陷、错误或其他问题进行测试。它被认为是开发过程的核心部分，因为它使测试人员和开发人员能够作为一个团队一起工作，从而提高整体性能。它还有助于确保成功交付高质量的产品。通常执行测试，以便测试人员可以在开发过程的每个阶段及早识别和解决问题。</p><p>敏捷测试主要原则，如下所示：</p><ol><li>连续测试：测试应由敏捷团队持续进行，以确保持续的开发进度。</li><li>持续反馈：此过程通常鼓励从客户那里获得反馈，以确保产品满足客户或客户的要求。</li><li>团队合作或集体工作：不仅是测试人员，开发人员，业务分析师也可以执行软件测试或应用程序测试。</li><li>清洁代码：当团队测试软件以确保代码干净、简单和紧凑时，将保持软件质量。在测试阶段发现的所有错误和缺陷都会由敏捷团队在同一迭代中快速修复。</li><li>更少的文档：此过程通常涉及使用可重用的清单，而不是冗长的文档。</li><li>测试驱动：在其他传统方法中，测试仅在实现后执行，但在敏捷测试中，测试是在实现期间完成的，以便可以及时删除错误或任何问题。</li><li>客户满意度：在敏捷测试过程中，向客户或客户显示开发进度，以便他们可以调整和更新其需求。这样做是为了确保客户满意度。</li></ol><h2 id="4-敏捷测试人员应该具备哪些优秀品质？"><a href="#4-敏捷测试人员应该具备哪些优秀品质？" class="headerlink" title="4.敏捷测试人员应该具备哪些优秀品质？"></a>4.敏捷测试人员应该具备哪些优秀品质？</h2><ul><li>积极的态度和解决方案导向</li><li>专注于目标</li><li>优秀的沟通技巧</li><li>了解并满足客户需求</li><li>有关敏捷过程及其原则的基本知识</li><li>批判性和创造性思维</li><li>有效分享想法</li><li>根据需求计划和确定工作的优先级</li><li>应对变化</li></ul><h2 id="5-重构是什么意思？"><a href="#5-重构是什么意思？" class="headerlink" title="5.重构是什么意思？"></a>5.重构是什么意思？</h2><p>重构基本上是一种涉及改变或修改软件内部结构的活动，而不对其外部行为或功能进行任何更改。在这种情况下，开发人员进行一些更改或修改代码以增强和改进软件的内部结构。敏捷软件开发过程中最流行和广泛使用的重构技术之一是红绿。重构过程使代码更具可读性、可理解性和更简洁。重构的持续习惯有助于更轻松地扩展和维护代码。</p><h2 id="6-冲刺积压和产品积压有什么区别？"><a href="#6-冲刺积压和产品积压有什么区别？" class="headerlink" title="6.冲刺积压和产品积压有什么区别？"></a>6.冲刺积压和产品积压有什么区别？</h2><p><strong>冲刺积压工作</strong>：它通常由开发团队拥有。它仅包含与特定冲刺 （sprint） 相关的功能和要求。它被视为产品积压工作的子集。它由完成特定冲刺必须完成的所有操作一起编译而成。它仅包括在每个敏捷冲刺 （sprint） 期间可以完成的项目。它仅在特定冲刺中特定于冲刺目标。</p><p><strong>产品待办列表</strong>：它通常由项目所有者拥有和维护。它通常包含产品的每个功能以及产品的要求。它被编译为完成整个过程所必须完成的所有操作。它只是将每个项目分解为一系列步骤。它更具体地针对产品的最终目标。</p><h2 id="7-什么是敏捷中的冲刺和零冲刺？"><a href="#7-什么是敏捷中的冲刺和零冲刺？" class="headerlink" title="7.什么是敏捷中的冲刺和零冲刺？"></a>7.什么是敏捷中的冲刺和零冲刺？</h2><p><strong>冲刺</strong>：它通常是指软件开发中太大且复杂的用户故事，在开发团队运行限时调查之前无法估计。这些故事可用于各种活动，如研究、设计、探索、原型制作等。创建冲刺通常是为了解决项目中的一些技术问题和设计问题。</p><p><strong>零冲刺</strong>：它通常是指在第一个冲刺之前的第一步或预准备步骤。它包括所有活动，例如设置开发环境，准备积压工作等。</p><h2 id="8-敏捷方法和传统软件开发方法有什么区别？"><a href="#8-敏捷方法和传统软件开发方法有什么区别？" class="headerlink" title="8.敏捷方法和传统软件开发方法有什么区别？"></a>8.敏捷方法和传统软件开发方法有什么区别？</h2><p><strong>敏捷软件开发</strong>：它是一种迭代方法，用于设计复杂的软件。在这种方法中，项目团队可以更加灵活，并确保最终满足客户的要求。它开发以客户为中心的产品，并在更短的冲刺中交付。</p><p><strong>传统软件开发</strong>：它是一种线性方法，用于设计简单的软件。在这种方法中，过程的所有阶段通常按顺序发生。它更适合在范围内更改的可能性可以忽略不计的项目。</p><h2 id="9-敏捷中的“速度”一词是什么意思？"><a href="#9-敏捷中的“速度”一词是什么意思？" class="headerlink" title="9.敏捷中的“速度”一词是什么意思？"></a>9.敏捷中的“速度”一词是什么意思？</h2><p>速度基本上是一个度量单位，用于测量或计算敏捷开发团队在单个冲刺中可以成功完成多少工作以及完成项目需要多少时间。它被广泛用作校准工具，帮助开发团队创建准确有效的时间表。它还用于识别问题并衡量随时间推移而发生的改进。</p><h2 id="10-每日站立会议是什么意思？"><a href="#10-每日站立会议是什么意思？" class="headerlink" title="10.每日站立会议是什么意思？"></a>10.每日站立会议是什么意思？</h2><p>每日站立会议是敏捷团队所有成员之间的日常会议。它的主要目的是了解每个从事Scrum任务的团队成员的当前进度和表现。会议主要在上午举行，通常涉及产品所有者、开发人员和 Scrum 主管。</p><p>这些会议通常出于以下原因举行：</p><ul><li>要知道昨天做了什么，今天的计划是什么。</li><li>为了更好地理解目标。</li><li>确保每个团队成员都在朝着同一个目标努力。</li><li>将团队成员的问题集中起来，以便快速解决问题。</li><li>让每个人都了解最新信息并帮助团队保持井井有条。</li></ul><h2 id="11-什么是增量和迭代开发？"><a href="#11-什么是增量和迭代开发？" class="headerlink" title="11.什么是增量和迭代开发？"></a>11.什么是增量和迭代开发？</h2><p><strong>迭代开发</strong>：它基本上是一个软件开发过程，其中软件开发周期（冲刺和发布）重复，直到获得最终产品。根据客户或用户的反馈，再次以周期或发布和冲刺的方式开发产品，即以重复的方式添加新功能。</p><p><strong>增量开发</strong>：它基本上是一个软件开发过程，其中开发工作被切成增量或部分或部分。在这种情况下，软件是分段或增量开发和交付的，每个部分都有一套完整的功能。增量可以很小，也可以很大，每个增量都经过全面编码和测试。在测试每个增量之后，它们都被集成在一起，以便它们作为一个整体工作。</p><h2 id="12-什么是产品路线图？"><a href="#12-什么是产品路线图？" class="headerlink" title="12.什么是产品路线图？"></a>12.什么是产品路线图？</h2><p>顾名思义，产品路线图是一个强大的工具，可以描述产品如何随着时间的推移而增长。它是创建产品愿景的产品功能的整体视图。它还指示正在构建的开发内容，新产品将实现的业务目标，产品将解决的问题等。产品路线图归产品经理所有。它还鼓励开发团队共同努力，以实现成功交付产品的预期目标。</p><h2 id="13-敏捷中最常用的项目管理工具有哪些？"><a href="#13-敏捷中最常用的项目管理工具有哪些？" class="headerlink" title="13.敏捷中最常用的项目管理工具有哪些？"></a>13.敏捷中最常用的项目管理工具有哪些？</h2><ul><li>Icescrum </li><li>Rally Software </li><li>Agilent </li><li>Version One </li><li>Agilo </li><li>X-planner</li></ul><h2 id="14-敏捷和Scrum有什么区别？"><a href="#14-敏捷和Scrum有什么区别？" class="headerlink" title="14.敏捷和Scrum有什么区别？"></a>14.敏捷和Scrum有什么区别？</h2><p><strong>敏捷</strong>： 它是一种主要用于软件开发的方法。在这种方法中，复杂的项目被分解为可以在特定时间范围内实现的较小单元。它始终让客户参与开发过程。</p><p><strong>Scrum</strong>：有不同的敏捷方法，Scrum就是其中之一。它促进类似于敏捷的问责制、功能和团队合作。简而言之，它是敏捷方法的一种改进方式，并具有与敏捷相同的原则和价值观，并添加了一些自己独特的功能。</p><h2 id="15-结对编程是什么意思？写下它的优点。"><a href="#15-结对编程是什么意思？写下它的优点。" class="headerlink" title="15.结对编程是什么意思？写下它的优点。"></a>15.结对编程是什么意思？写下它的优点。</h2><p>结对编程，顾名思义，是一种编程类型，其中两个人一起编写代码并在一台机器或计算机上并排工作。它基本上是一种主要用于敏捷软件开发的技术。在这种类型的编程中，一个人编写代码，另一个人检查和审查每一行代码。他们俩在工作时也会转换角色。</p><p>结对编程的优势：</p><ul><li>开发更高质量的代码</li><li>降低出错风险</li><li>分享知识的有效方式</li><li>提高生产力</li><li>改善团队协作</li></ul><h2 id="16-什么是敏捷宣言？它的价值观和原则是什么？"><a href="#16-什么是敏捷宣言？它的价值观和原则是什么？" class="headerlink" title="16.什么是敏捷宣言？它的价值观和原则是什么？"></a>16.什么是敏捷宣言？它的价值观和原则是什么？</h2><p>敏捷宣言基本上是一个由敏捷中表达的价值观和原则组成的文档。它创建于2001年初。它仅由 4 个价值观和 12 个关键原则组成。该宣言有助于开发团队更有效地工作，并提供清晰且可衡量的结构，以促进团队协作、迭代开发等。它是专门为改进开发方法而设计的。</p><p><strong>4个敏捷价值观：</strong></p><ol><li>流程和工具上的个人和交互：它侧重于给予与客户沟通更多的关注和重视。</li><li>工作软件超过全面的文档：它侧重于项目的完成，并确保项目正在完成最终的可交付成果。</li><li>通过合同谈判进行客户协作：它侧重于让客户参与项目的所有阶段，以便最终产品不会缺少客户所需的任何要求。这样做是为了确保100%的客户满意度。</li><li>响应变化而不是遵循计划：它专注于变化，并激励团队快速采用变化，以便交付更高质量的产品。因此，敏捷在短冲刺中工作，以便可以很好地利用更改。</li></ol><p><strong>12项敏捷原则：</strong></p><ol><li>客户满意度：首要任务是满足客户需求，确保100%的客户满意度。</li><li>欢迎更改：更改对于改进很重要，因此即使在开发过程的后期，也可以在整个开发期间引入和解决更改。</li><li>经常交付：产品必须尽快交付，因此专注于更短的时间。</li><li>共事：业务利益干系人和团队成员在整个开发过程中协同工作，以实现更好的协作。</li><li>积极进取的团队：为了提供高质量的产品，团队成员受到激励和鼓励。团队成员将获得有效执行所需的环境和支持。</li><li>面对面：敏捷强调面对面的沟通，这是传达信息的最有效和最有效的方式。它可以帮助团队以有效的方式传达简单和复杂的信息。</li><li>工作软件：向客户提供工作软件是敏捷的主要关注点。工作软件或产品是衡量最终产品进展的主要指标。</li><li>恒定的步伐：敏捷促进可持续发展。参与敏捷过程的所有团队、发起人、开发人员和用户都应保持恒定的速度，以便在短时间内交付工作软件。</li><li>好的设计：专注于良好的设计和技术细节，以提高质量和敏捷性（快速而优雅）。</li><li>单纯：团队专注于必不可少的任务和功能，并减少在复杂功能和非必需任务上花费的工作量和时间。这样做是为了保持简单。</li><li>自组织：敏捷团队应该是跨职能和自组织的。它不应该依靠经理来分配工作，而应该找到自己的工作并管理职责和时间表。这样的团队不仅有助于交付高质量的软件，而且还提供最佳的设计、要求和架构。</li><li>反映和调整：为了提高团队的效率，团队反思如何变得更有效率，并定期评估他们的工作方式。这样做是为了人们可以从他们的错误中吸取教训，并采取一些步骤来提高他们在下一次迭代中的性能。</li></ol><h2 id="17-敏捷中的燃尽图是什么？"><a href="#17-敏捷中的燃尽图是什么？" class="headerlink" title="17.敏捷中的燃尽图是什么？"></a>17.敏捷中的燃尽图是什么？</h2><p><strong>燃尽图</strong>：它是一种图表类型，用于显示或表示已完成的工作量以及冲刺或迭代的总工作量。</p><h2 id="18-燃尽图有哪些不同类型？"><a href="#18-燃尽图有哪些不同类型？" class="headerlink" title="18.燃尽图有哪些不同类型？"></a>18.燃尽图有哪些不同类型？</h2><p><strong>产品燃尽图</strong>：它是一种图表，用于显示每个已完成冲刺 （sprint） 的故事点，以便描述需求随时间推移的完成情况。它主要显示团队正在实现多少产品目标以及还剩下多少工作。</p><p><strong>冲刺燃尽图</strong>：它是一种图表，用于显示特定冲刺的Scrum团队的剩余工作。它使团队的工作可见，并显示完成工作的速率以及剩余的完成量。</p><p><strong>发布燃尽图</strong>：它是一种图表，用于显示团队如何针对发布工作取得进展。此图表由 Scrum 团队在每个冲刺 （sprint） 结束时更新。查看每个冲刺期间正在执行的过程非常重要。</p><p><strong>缺陷燃尽图</strong>：它是一种图表，用于显示正在识别和修复或删除的缺陷总数。</p><h2 id="19-列出除Scrum之外的三个主要敏捷框架，用于产品开发。"><a href="#19-列出除Scrum之外的三个主要敏捷框架，用于产品开发。" class="headerlink" title="19.列出除Scrum之外的三个主要敏捷框架，用于产品开发。"></a>19.列出除Scrum之外的三个主要敏捷框架，用于产品开发。</h2><p>除了Scrum之外，三个主要的敏捷框架是：</p><ol><li>看板(KanBan)</li><li>测试驱动开发 （TDD）</li><li>功能驱动开发 （FDD）</li></ol><h2 id="20-什么是“Planning-Poker”技术？"><a href="#20-什么是“Planning-Poker”技术？" class="headerlink" title="20.什么是“Planning Poker”技术？"></a>20.什么是“Planning Poker”技术？</h2><p>Planning Poker，也称为Scrum Poker，是一种基于共识的技术，不仅可以帮助敏捷团队估计完成产品待办事项的每个计划所需的时间和精力，还可以在时间和用户故事过程中识别问题。它使会议更简短、更有成效，并在整个团队的参与下创建估算。它主要用于避免其他参与者的影响，并迫使每个人独立思考并发表意见。</p><h2 id="21-什么是冲刺计划会议、冲刺评审会议和冲刺回顾会议？"><a href="#21-什么是冲刺计划会议、冲刺评审会议和冲刺回顾会议？" class="headerlink" title="21.什么是冲刺计划会议、冲刺评审会议和冲刺回顾会议？"></a>21.什么是冲刺计划会议、冲刺评审会议和冲刺回顾会议？</h2><p><strong>冲刺计划会议</strong>：在此会议中，将讨论对团队很重要的功能和产品积压工作项（用户情景）。此会议通常由产品负责人、Scrum Master 和 Scrum 团队参加。这是每周一次的会议，通常持续约一个小时。</p><p><strong>冲刺评审会议</strong>： 在这次会议上，Scrum团队对产品进行了演示。在此之后，产品所有者确定哪些项目已完成，哪些项目未完成。他还根据客户或利益相关者的反馈向产品待办事项添加了一些其他项目。其主要目的是检查冲刺中创建的产品，并在需要时对其进行修改。</p><p><strong>冲刺回顾会议</strong>：此会议在 Sprint 计划会议之后举行。在这次会议上，Scrum团队再次开会检查自己，讨论过去的错误，潜在的问题和解决这些问题的方法。这次会议的主要目的是改进开发过程。这次会议持续约2-3小时。</p><h2 id="22-“增量”一词是什么意思？"><a href="#22-“增量”一词是什么意思？" class="headerlink" title="22.“增量”一词是什么意思？"></a>22.“增量”一词是什么意思？</h2><p>增量只是冲刺期间完成的所有产品积压工作项的总和或总计，以及所有先前冲刺 （sprint） 的增量值。它是在当前和以前的冲刺 （sprint） 中完成的总工时。</p><h2 id="23-敏捷的标准或通用指标是什么？解释。"><a href="#23-敏捷的标准或通用指标是什么？解释。" class="headerlink" title="23.敏捷的标准或通用指标是什么？解释。"></a>23.敏捷的标准或通用指标是什么？解释。</h2><p>敏捷指标基本上是用于衡量团队工作的标准指标。这些指标用于确定工作质量、生产力、进度、团队健康状况等。它的主要重点是交付给客户的价值以及最终用户受到的影响程度。<br>敏捷项目的标准指标</p><ul><li>速度：它衡量开发团队在冲刺期间完成的工作量。它提供了有关进度、能力等的想法。</li><li>累积流程图：它是用于衡量团队正在进行的工作的当前状态的流程图。它仅用于跟踪敏捷团队的进度并管理流程稳定性。</li><li>缺陷去除意识：它用于衡量开发团队在发布之前消除缺陷的能力。它有助于通过工作团队保持产品质量。</li><li>工作类别分配：它用于衡量我们在哪里花费或投入时间，以便我们可以调整我们的优先事项。</li><li>冲刺燃尽指标：它用于衡量与估计的Scrum任务相比完成的冲刺或任务的总数。它通常跟踪冲刺期间任务的进度。</li><li>缺陷解决时间：它用于衡量团队识别和修复软件中的缺陷或错误所花费的时间。修复错误涉及几个过程。</li><li>时间覆盖率或代码覆盖率：它用于测量在测试期间为代码提供的时间。它有助于人们了解测试了多少代码，也有助于评估测试性能。</li><li>提供的业务价值：它用于衡量工作团队的效率。</li></ul><h2 id="24-什么是Scrum？写下它的优点。"><a href="#24-什么是Scrum？写下它的优点。" class="headerlink" title="24.什么是Scrum？写下它的优点。"></a>24.什么是Scrum？写下它的优点。</h2><p>Scrum是一个轻量级的流程框架，可帮助Scrum团队协同工作并管理产品开发，从而在最短的时间内交付产品。Scrum团队在最短的时间内提供的产品被称为打印。其主要目的是在基于团队的开发环境中管理任务。它特别用于管理软件产品的项目开发，也可用于与业务相关的上下文。<br>Scrum的优势：</p><ul><li>向用户和客户快速发布产品</li><li>确保有效利用时间和金钱，从而节省成本</li><li>最适合快速发展的开发项目</li><li>能够在更改发生时合并更改</li><li>强调创造力和创新，提高商业价值</li><li>大型和复杂的项目分为小而易于管理的冲刺</li></ul><h2 id="25-Scrum中有哪些不同的角色？"><a href="#25-Scrum中有哪些不同的角色？" class="headerlink" title="25.Scrum中有哪些不同的角色？"></a>25.Scrum中有哪些不同的角色？</h2><p>Scrum中基本上有三种不同的角色，如下所示：</p><ul><li>Scrum Master：Scrum Master基本上是一个团队的领导者或主管，负责确保Scrum团队正确执行提交的任务。</li><li>Product Owner：产品负责人基本上是项目的利益相关者，负责管理产品积压工作。他还负责定义为团队构建的愿景。</li><li>Development Team：它涉及一个人，每个人都负责集体工作以完成特定项目。该团队负责开发实际的产品增量并实现冲刺目标。</li></ul><h2 id="26-Scrum-Master是什么意思？Scrum-Master的职责是什么？"><a href="#26-Scrum-Master是什么意思？Scrum-Master的职责是什么？" class="headerlink" title="26.Scrum Master是什么意思？Scrum Master的职责是什么？"></a>26.Scrum Master是什么意思？Scrum Master的职责是什么？</h2><p>Scrum Master是Scrum的领导者，即负责管理和促进敏捷开发团队并确保遵循Scrum框架的人。Scrum Master也被称为团队的教练，帮助团队成员尽可能做到最好。</p><p>Scrum Master 的职责 ：</p><ul><li>保护团队免受干扰</li><li>激励和指导团队实现冲刺目标</li><li>建立一个自组织和积极进取的团队</li><li>提高团队的效率和生产力</li><li>确保团队在冲刺期间提供预期价值</li><li>确保团队遵循Scrum的价值观，实践和原则</li><li>消除外部障碍并管理内部障碍</li><li>主持会议并解决任何类型的问题</li></ul><h2 id="27-Scrum框架的主要工件是什么？"><a href="#27-Scrum框架的主要工件是什么？" class="headerlink" title="27.Scrum框架的主要工件是什么？"></a>27.Scrum框架的主要工件是什么？</h2><p>Scrum框架有三个主要工件：</p><ul><li>产品待办列表：它是产品中需要的客户或利益相关者的所有需求的列表，应在项目结束之前完成。</li><li>冲刺积压工作：它是所有最终用户故事、错误修复、工作项等的列表，这些内容由 Scrum 完成并选择在当前冲刺期间完成。</li><li>产品增量：它是从每个Sprint的完成派生的最终产品版本。</li></ul><h2 id="28-解释术语-Scrum-中的用户故事、史诗和任务？"><a href="#28-解释术语-Scrum-中的用户故事、史诗和任务？" class="headerlink" title="28.解释术语 Scrum 中的用户故事、史诗和任务？"></a>28.解释术语 Scrum 中的用户故事、史诗和任务？</h2><p>Scrum活动中通常使用许多技术术语。其中一些给出如下：</p><ul><li>史诗：它基本上是一个大故事，无法在单个冲刺中完成。因此，史诗在处理之前被细分为多个较小的用户故事。</li><li>用户故事： 这些是可以在一个冲刺中安装和完成的最小单元。用户情景进一步细分为不同的任务。</li><li>任务：这些是将用户故事转换为可行组件所必需的详细工作。</li></ul><h2 id="29-Scrum项目中最常用的重要工具是什么？"><a href="#29-Scrum项目中最常用的重要工具是什么？" class="headerlink" title="29.Scrum项目中最常用的重要工具是什么？"></a>29.Scrum项目中最常用的重要工具是什么？</h2><p>Scrum项目中最常用的工具有：</p><ul><li>Version One </li><li>Sprintster </li><li>Atlassian JIRA </li><li>RTC Jazz, etc.</li></ul><h2 id="30-在-Scrum-中解释时间盒。"><a href="#30-在-Scrum-中解释时间盒。" class="headerlink" title="30.在 Scrum 中解释时间盒。"></a>30.在 Scrum 中解释时间盒。</h2><p>时间盒是一种重要的时间管理技术或工具，用于限制完成任务所花费的时间量。它只是为每个任务允许一个固定的时间单位，这个单位被称为时间盒。时间框的最大长度为 15 分钟。它不仅有助于提高注意力，还可以提高生产力。Scrum中有一些事件，所有这些事件都是有时间限制的，这意味着所有这些事件都被分配了任务的最大和固定的时间单位。下面列出了有时间限制的事件：</p><ul><li>Sprint 冲刺</li><li>Sprint Planning 冲刺计划</li><li>Daily Scrum  每日Scrum  </li><li>Sprint Review  冲刺审查</li><li>Sprint retrospective  冲刺回顾</li></ul><h2 id="31-解释-Scrum-中的“障碍”一词。"><a href="#31-解释-Scrum-中的“障碍”一词。" class="headerlink" title="31.解释 Scrum 中的“障碍”一词。"></a>31.解释 Scrum 中的“障碍”一词。</h2><p>障碍是阻碍或阻止团队合作进展的东西。它导致团队无法以更好的方式按时执行任务，从而减慢速度。Scrum主管有责任消除或解决障碍。障碍可以是下面列出的任何内容：</p><ul><li>缺少资源</li><li>严格的老板或团队成员</li><li>技术或操作问题</li><li>停电</li><li>缺乏对敏捷或Scrum的理解</li><li>战争、天气等外部问题。</li><li>业务问题</li></ul><h2 id="32-Sashimi在-Scrum-中的主要角色是什么？"><a href="#32-Sashimi在-Scrum-中的主要角色是什么？" class="headerlink" title="32.Sashimi在 Scrum 中的主要角色是什么？"></a>32.Sashimi在 Scrum 中的主要角色是什么？</h2><p>Sashimi基本上是一个日语单词，其含义是刺穿身体。在Scrum中，Sashimi是一种技术，仅用于在产品显示后检查所有功能（软件开发周期的每个阶段）是否完成。功能包括需求分析、规划、设计、开发、测试和文档编制。</p><h2 id="33-解释-Scrum-中的“故事点”一词。"><a href="#33-解释-Scrum-中的“故事点”一词。" class="headerlink" title="33.解释 Scrum 中的“故事点”一词。"></a>33.解释 Scrum 中的“故事点”一词。</h2><p>故事点基本上是一个单位，用于估计完成或执行特定任务或用户情景所需的总工作量。它提供了更准确的度量，减少了计划时间，更准确地预测了发布日期。</p><h2 id="34-crums中的Scrum是什么意思？-Scrum-of-Scrums-SoS"><a href="#34-crums中的Scrum是什么意思？-Scrum-of-Scrums-SoS" class="headerlink" title="34.crums中的Scrum是什么意思？-Scrum of Scrums (SoS)"></a>34.crums中的Scrum是什么意思？-Scrum of Scrums (SoS)</h2><p>SOS，顾名思义是一种敏捷技术，涉及与多个Scrum团队会面，并整合从事同一项目的每个团队的工作。简而言之，它协调需要协同工作以提供复杂解决方案的多个团队的工作。在此会议中，各个团队的成员或代表分享有关各自团队工作的高级更新。其主要目的是通过消除障碍（如果存在）来确保协调和整合多个团队的产出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;敏捷或敏捷方法或敏捷过程定义&quot;&gt;&lt;a href=&quot;#敏捷或敏捷方法或敏捷过程定义&quot; class=&quot;headerlink&quot; title=&quot;敏捷或敏捷方法或敏捷过程定义&quot;&gt;&lt;/a&gt;敏捷或敏捷方法或敏捷过程定义&lt;/h1&gt;&lt;p&gt;顾名思义，敏捷方法论是一组方法和实践，其中软</summary>
      
    
    
    
    <category term="开发方法" scheme="http://example.com/categories/%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95/"/>
    
    
    <category term="scrum" scheme="http://example.com/tags/scrum/"/>
    
  </entry>
  
</feed>
